# SystemC_Course_Project
Use SystemC to implement a hardware-software co-simulation of the Diffie-Hellman key exchange protocol.



## Project Description

This project will use Diffie-Hellman key exchange protocol, originally written in C and distributed as a part of the NetBench benchmark suite. The goal is to rewrite it using SystemC and model one of its computationally intensive functions,  NN_DigitMult, as a hardware module (i.e., datapath + controller).

  The reference output is as followed:

  *** Agreed Key:  09 2a f1 41 e2 93 61 d5 

  *** Agreed Key:  64 30 94 c5 da d2 f6 da 49 6d 67 f1 16 55 b3 ea ee a2 c0 30 2b b5 4f 05 9e a4 58 ac 97 3b b9 a0 25 b7 56 fe 82 73 bb 22 d4 31 36 60 7f 41 e9 47 97 b9 5e 27 99 3e 73 f0 28 da b5 25 da e4 61 84 

Now take a look at sc_main() in dhdemo.cpp, where we instantiate modules 
DH_SW (software) and DH_HW_MULT (hardware multiplier).  In addition to 
the data signals (operand1, operand2, result1, result2), there are two 
control signals exchanged between software and hardware: enable and done.
The enable signal is generated by software to enable hardware multiplication, 
and the done signal is generated by hardware to indicate that multiplication 
has been completed.  One of your tasks will be to implement an appropriate 
handshaking protocol using these two signals.  Currently, software and 
hardware are synchronized using only enable and explicit timing delays. 
(As an example, we use 100 ns for computation and 10 ns for communication.)

DH_HW_MULT is an instance of the dh_hw_mult module, with a THREAD process
sensitive to the enable signal.  DH_SW is an instance of the dh_sw module, 
with a THREAD process sensitive to the done signal.  The current version 
of the dh_hw_mult module does NOT generate done.  Hence, software-hardware
communication has to rely on timed waits at this point.

Your first task is to replace timed waits with the enable-done handshaking
protocol in both hardware (dh_hw_mult) and software (dh_sw).  For example,
the hardware should wait for enable signal to be asserted.  Once enable has
been asserted (by the software), the hardware should perform multiplication.
Then, it should output the result and assert done.  The hardware should
deassert done only if enable has been deasserted.  To implement this, you 
need to: (1) add a clock input to the hardware and make it a CTHREAD, and
(2) code a simple FSM with 4 states: 
 a. WAIT - wait for the enable signal to be asserted. 
 b. EXECUTE - multiply the two inputs (use the multiplication code as is). 
 c. OUTPUT - write to the module's output ports, assert the done signal. 
 d. FINISH - check if enable is deasserted; if so, deassert done.

NOTE: NN_DigitMult (dh_sw.cpp) also needs to be modified to complete your 
handshaking protocol.  Do NOT feed any clocks to the software module!  
There must be NO timed waits (e.g., wait(10, SC_NS)) in your final code.

Your second task is to design the datapath and controller of the hardware
multiplier.  You need to extract the multiplication code inside the EXECUTE 
state and convert it to the structural description using familiar registers,
multiplexers, shifters, adders, multipliers, etc.  Then, you need to split
the EXECUTE state into as many states as necessary to control your datapath.
Thus, your datapath controller becomes "embedded" into the handshaking FSM.
(Alternatively, you can separate the datapath controller and the handshaking
FSM into two communicating state machines.)

Your final design should produce the same output as the original code.
Beware that simulations will slow down as you refine your design.


## Test Data Results

The first iteration of NN_DigitMult running without the hardware implementation generates the following data:
	Data: b = 1, c = 2147483648
	 bHigh = 0, bLow = 1
	 cHigh = 32768, cLow = 0
	 a[0] = 0, a[1] = 0
	 t = 32768, u = 0
	After if_1
	 a[0] = 0, a[1] = 0
	 t = 32768, u = 2147483648
	After if_2
	 a[0] = 2147483648, a[1] = 0
	 t = 32768, u = 2147483648

Ten iterations provides the following results: 
a[0] = 2147483648, a[1] = 0
a[0] = 2147483648, a[1] = 554094031
a[0] = 2147483648, a[1] = 573719873
a[0] = 0, a[1] = 573719874
a[0] = 3758096384, a[1] = 286859936
a[0] = 0, a[1] = 286859937
a[0] = 0, a[1] = 143429968
a[0] = 4, a[1] = 0
a[0] = 8, a[1] = 0
a[0] = 1, a[1] = 0

## Improved hardware implementation
The improved FSM (v2) provides the following data within the blink of an eye (Extremely fast)

process_hw_mult: ES_STAGE_1
process_hw_mult: ES_STAGE_2
Data: b_reg = 1, c_reg = 2147483648
 bHigh = 0, bLow = 1
 cHigh = 32768, cLow = 0
process_hw_mult: OUTPUT_STATE
NN_DigitMult: Data: A0 = 2147483648, A1 = 0

process_hw_mult: ES_STAGE_1
process_hw_mult: ES_STAGE_2
Data: b_reg = 1108188063, c_reg = 2147483648
 bHigh = 16909, bLow = 39839
 cHigh = 32768, cLow = 0
process_hw_mult: OUTPUT_STATE
NN_DigitMult: Data: A0 = 2147483648, A1 = 554094031

process_hw_mult: ES_STAGE_1
process_hw_mult: ES_STAGE_2
Data: b_reg = 1147439747, c_reg = 2147483648
 bHigh = 17508, bLow = 35459
 cHigh = 32768, cLow = 0
process_hw_mult: OUTPUT_STATE
NN_DigitMult: Data: A0 = 2147483648, A1 = 573719873

process_hw_mult: ES_STAGE_1
process_hw_mult: ES_STAGE_2
Data: b_reg = 764959832, c_reg = 3221225472
 bHigh = 11672, bLow = 23640
 cHigh = 49152, cLow = 0
process_hw_mult: OUTPUT_STATE
NN_DigitMult: Data: A0 = 0, A1 = 573719874

process_hw_mult: ES_STAGE_1
process_hw_mult: ES_STAGE_2
Data: b_reg = 458975899, c_reg = 2684354560
 bHigh = 7003, bLow = 27291
 cHigh = 40960, cLow = 0
process_hw_mult: OUTPUT_STATE
NN_DigitMult: Data: A0 = 3758096384, A1 = 286859936

process_hw_mult: ES_STAGE_1
process_hw_mult: ES_STAGE_2
Data: b_reg = 327839928, c_reg = 3758096384
 bHigh = 5002, bLow = 28856
 cHigh = 57344, cLow = 0
process_hw_mult: OUTPUT_STATE
NN_DigitMult: Data: A0 = 0, A1 = 286859937

process_hw_mult: ES_STAGE_1
process_hw_mult: ES_STAGE_2
Data: b_reg = 208625408, c_reg = 2952790016
 bHigh = 3183, bLow = 24320
 cHigh = 45056, cLow = 0
process_hw_mult: OUTPUT_STATE
NN_DigitMult: Data: A0 = 0, A1 = 143429968

process_hw_mult: ES_STAGE_1
process_hw_mult: ES_STAGE_2
Data: b_reg = 2, c_reg = 2
 bHigh = 0, bLow = 2
 cHigh = 0, cLow = 2
process_hw_mult: OUTPUT_STATE
NN_DigitMult: Data: A0 = 4, A1 = 0

process_hw_mult: ES_STAGE_1
process_hw_mult: ES_STAGE_2
Data: b_reg = 4, c_reg = 2
 bHigh = 0, bLow = 4
 cHigh = 0, cLow = 2
process_hw_mult: OUTPUT_STATE
NN_DigitMult: Data: A0 = 8, A1 = 0

process_hw_mult: ES_STAGE_1
process_hw_mult: ES_STAGE_2
Data: b_reg = 1, c_reg = 1
 bHigh = 0, bLow = 1
 cHigh = 0, cLow = 1
process_hw_mult: OUTPUT_STATE
NN_DigitMult: Data: A0 = 1, A1 = 0
Counter = 10

These results match the non-hardware implementation.

The results of the full run are as follows:
4.6 seconds for full simulation (vs. 10 seconds for two multiplications with old FSM)

Counter = 757000
*** Agreed Key:  09 2a f1 41 e2 93 61 d5 

Counter = 1500000
*** Agreed Key:  64 30 94 c5 da d2 f6 da 49 6d 67 f1 16 55 b3 ea ee a2 c0 30 2b b5 4f 05 9e a4 58 ac 97 3b b9 a0 25 b7 56 fe 82 73 bb 22 d4 31 36 60 7f 41 e9 47 97 b9 5e 27 99 3e 73 f0 28 da b5 25 da e4 61 84 

This matches the golden reference, showing the hardware works successfully. 









